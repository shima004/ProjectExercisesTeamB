{{ define "blockBreaker"}}
<!DOCTYPE html>
<html lang="ja-jp">
  <head>
    <meta charset="utf-8" />
    <title>ブロック崩し</title>
    <!-- <style>
    	* { padding: 0; margin: 0; }
    	canvas { background: #000; display: block; margin: 0 auto; }
    </style> -->
</head>
  {{ template "header" . }}
  <script src="static/js/blockBreaker.js" defer></script>
  <link rel="stylesheet" href="static/css/blockBreaker.css">
  <body>
    {{ template "navibar" . }}
    <div class="container">
      <!-- この下にコンテンツを作成してください -->
      <h1>ブロック崩し</h1>
      <canvas id="myCanvas" width="480" height="320"></canvas>
      <!-- <script>
        var canvas = document.getElementById("myCanvas");
        var ctx = canvas.getContext("2d");
        var x = canvas.width / 2;
        var y = canvas.height - 30;
        var dx = Math.floor(Math.random() + 2);
        var dy = Math.floor(Math.random() + 2) * -1;
        var coinRadius = 6;
        var ballRadius = 10;
        var paddleHeight = 10;
        var paddleWidth = 75;
        var paddleX = (canvas.width - paddleWidth) / 2;
        var rightPressed = false;
        var leftPressed = false;
        var brickRowCount = 3;
        var brickColumnCount = 5;
        var brickWidth = 75;
        var brickHeight = 20;
        var brickPadding = 10;
        var brickOffsetTop = 30;
        var brickOffsetLeft = 30;
        var score = 0;
        var lives = 3;
        var Coins = [];
        for (var c = 0; c < brickColumnCount; c++) {
          Coins[c] = [];
          for (var r = 0; r < brickRowCount; r++) {
            Coins[c][r] = { x: 0, y: 0, status: 1 };
          }
        }
        var bricks = [];
        for (var c = 0; c < brickColumnCount; c++) {
          bricks[c] = [];
          for (var r = 0; r < brickRowCount; r++) {
            bricks[c][r] = { x: 0, y: 0, status: 1 };
          }
        }
        document.addEventListener("keydown", keyDownHandler, false);
        document.addEventListener("keyup", keyUpHandler, false);
        document.addEventListener("mousemove", mouseMoveHandler, false);

        function mouseMoveHandler(e) {
          var relativeX = e.clientX - canvas.offsetLeft;
          if (relativeX > 0 && relativeX < canvas.width) {
            paddleX = relativeX - paddleWidth / 2;
          }
        }

        function keyDownHandler(e) {
          if (e.key == "Right" || e.key == "ArrowRight") {
            rightPressed = true;
          } else if (e.key == "Left" || e.key == "ArrowLeft") {
            leftPressed = true;
          }
        }

        function keyUpHandler(e) {
          if (e.key == "Right" || e.key == "ArrowRight") {
            rightPressed = false;
          } else if (e.key == "Left" || e.key == "ArrowLeft") {
            leftPressed = false;
          }
        }

        function collisionDetection() {
          //衝突判定
          for (var c = 0; c < brickColumnCount; c++) {
            for (var r = 0; r < brickRowCount; r++) {
              var b = bricks[c][r];
              if (b.status == 1) {
                if (
                  x > b.x &&
                  x < b.x + brickWidth &&
                  y > b.y &&
                  y < b.y + brickHeight
                ) {
                  dy = -dy;
                  b.status = 0;
                  score++;
                  if (score % 15 == 0) {
                    //ブロック復活
                    for (var c = 0; c < brickColumnCount; c++) {
                      for (var r = 0; r < brickRowCount; r++) {
                        bricks[c][r].status = 1;
                      }
                    }
                    if (paddleWidth > 20) {
                      //パドル大きさ変更
                      paddleWidth = paddleWidth - 5;
                    }
                    if (ballRadius > 20) {
                      //ボール大きさ変更
                      ballRadius = ballRadius - 5;
                    }
                  }
                }
              }
            }
          }
        }

        function drawScore() {
          ctx.font = "16px Arial";
          ctx.fillStyle = "#ff0000";
          ctx.fillText("Score: " + score, 8, 20);
        }

        function drawLives() {
          ctx.font = "16px Arial";
          ctx.fillStyle = "#00ff00";
          ctx.fillText("Lives: " + lives, canvas.width - 65, 20);
        }

        function drawBall() {
          ctx.beginPath();
          ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
          ctx.fillStyle = "#0095DD";
          ctx.fill();
          ctx.closePath();
        }

        function drawPaddle() {
          ctx.beginPath();
          ctx.rect(
            paddleX,
            canvas.height - paddleHeight,
            paddleWidth,
            paddleHeight
          );
          ctx.fillStyle = "#0095DD";
          ctx.fill();
          ctx.closePath();
        }

        function drawBricks() {
          for (var c = 0; c < brickColumnCount; c++) {
            for (var r = 0; r < brickRowCount; r++) {
              if (bricks[c][r].status == 1) {
                var brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
                var brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
                bricks[c][r].x = brickX;
                bricks[c][r].y = brickY;
                ctx.beginPath();
                ctx.rect(brickX, brickY, brickWidth, brickHeight);
                ctx.fillStyle = "#ff0000";
                ctx.fill();
                ctx.closePath();
              }
            }
          }
        }
        function drawCoins() {
          for (var c = 0; c < brickColumnCount; c++) {
            for (var r = 0; r < brickRowCount; r++) {
              var CoinX =
                c * (brickWidth + brickPadding) +
                brickOffsetLeft +
                brickWidth / 2;
              var CoinY =
                r * (brickHeight + brickPadding) +
                brickOffsetTop +
                brickHeight / 2;
              Coins[c][r].x = CoinX;
              Coins[c][r].y = CoinY;
              ctx.beginPath();
              ctx.arc(CoinX, CoinY, coinRadius, 0, Math.PI * 2);
              ctx.fillStyle = "#ffff00";
              ctx.fill();
              ctx.closePath();
            }
          }
        }

        function draw() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawBricks();
          drawBall();
          drawPaddle();
          drawCoins();
          drawScore();
          drawLives();
          collisionDetection();
          x += dx;
          y += dy;
          if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
            dx = -dx;
          }
          if (y + dy < ballRadius) {
            dy = -dy;
          } else if (y + dy > canvas.height - ballRadius) {
            if (x > paddleX && x < paddleX + paddleWidth) {
              dy = -dy;
            } else {
              lives--;
              if (!lives) {
                alert("GAME OVER");
                document.location.reload();
              } else {
                x = canvas.width / 2;
                y = canvas.height - 30;
                dx = Math.floor(Math.random() + 2);
                dy = Math.floor(Math.random() + 2) * -1;
                paddleX = (canvas.width - paddleWidth) / 2;
              }
            }
          }
        }
        var interval = setInterval(draw, 10);
      </script> -->
    </div>
  </body>
</html>
{{end}}